{
    "version": "https://jsonfeed.org/version/1",
    "title": "Walt's Blog • All posts by \"汇编\" tag",
    "description": "",
    "home_page_url": "http://waltcsz.github.io",
    "items": [
        {
            "id": "http://waltcsz.github.io/2023/08/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
            "url": "http://waltcsz.github.io/2023/08/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
            "title": "汇编基础知识",
            "date_published": "2023-08-20T09:58:02.000Z",
            "content_html": "<h1 id=\"汇编\"><a class=\"markdownIt-Anchor\" href=\"#汇编\">#</a> 汇编</h1>\n<h2 id=\"汇编指令\"><a class=\"markdownIt-Anchor\" href=\"#汇编指令\">#</a> 汇编指令</h2>\n<p>在 Linux 上，大部分双操作数的指令均已前者为目的操作数，后者为源操作数。</p>\n<h3 id=\"间接寻址\"><a class=\"markdownIt-Anchor\" href=\"#间接寻址\">#</a> 间接寻址</h3>\n<p>**[] ** 表示间接寻址，类似 c 语言的 ***** .</p>\n<pre><code class=\"language-assembly\">mov eax, [ebx+8]\t;若ebx储存值为0x4008，则该指令将0x4010处的值赋给eax\nmov eax, [0x4001]\t;将地址0x4001处的值赋给eax(该代码为推测，不一定合法)\nlea eax, [ebx]\t;直接将ebx的值赋值给eax\n</code></pre>\n<h3 id=\"常用命令\"><a class=\"markdownIt-Anchor\" href=\"#常用命令\">#</a> 常用命令</h3>\n<p>push 将数据入栈，pop 将栈顶数据弹出</p>\n<pre><code class=\"language-assembly\">push eip\t；将eip储存的值入栈\npop eip\t\t;将栈顶数据弹出并存入eip\n</code></pre>\n<p>mov 传送字节，相当于赋值语句。</p>\n<p>lea 装入有效地址，相当于取地址。</p>\n<pre><code class=\"language-assembly\">mov eax, ebx\t;将ebx的值赋给eax\nmov ecx, 0Ah\t;将ecx赋值为0x0A\n\nlea eax, [ebp+buf]\t;将局部变量buf的地址存入eax\n\n</code></pre>\n<p>call 调用函数。jmp 跳转指令。</p>\n<pre><code class=\"language-assembly\">call __printf\t;跳转printf函数\n\t\t\t\t;call相当于入栈当前eip后执行jmp\npush eip\njmp __printf\n</code></pre>\n<p>inc 将目标操作数自增 1</p>\n<p>dec 将目标操作数自减 1</p>\n<h3 id=\"比较和跳转\"><a class=\"markdownIt-Anchor\" href=\"#比较和跳转\">#</a> 比较和跳转</h3>\n<h2 id=\"寄存器\"><a class=\"markdownIt-Anchor\" href=\"#寄存器\">#</a> 寄存器</h2>\n<h3 id=\"通用寄存器\"><a class=\"markdownIt-Anchor\" href=\"#通用寄存器\">#</a> 通用寄存器</h3>\n<h4 id=\"指针寄存器\"><a class=\"markdownIt-Anchor\" href=\"#指针寄存器\">#</a> 指针寄存器</h4>\n<table>\n<thead>\n<tr>\n<th>32 位</th>\n<th>64 位</th>\n<th>名称</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>EBP</td>\n<td>RBP</td>\n<td>基址指针寄存器 (extended base pointer)</td>\n<td>指向栈帧的底部</td>\n</tr>\n<tr>\n<td>ESP</td>\n<td>RSP</td>\n<td>栈指针寄存器 (extended stack pointer)</td>\n<td>指向栈帧的顶部</td>\n</tr>\n<tr>\n<td>ESI</td>\n<td>RSI</td>\n<td>源变址寄存器 (Source Index)</td>\n<td>字符串操作源指针</td>\n</tr>\n<tr>\n<td>EDI</td>\n<td>RDI</td>\n<td>目的指针寄存器 (Destination Index)</td>\n<td>字符串操作目标指针</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"数据寄存器\"><a class=\"markdownIt-Anchor\" href=\"#数据寄存器\">#</a> 数据寄存器</h4>\n<p>数据寄存器主要用来保存操作数和运算结果等信息。</p>\n<p>在 64 位系统下，32 位寄存器代表对应 64 位寄存器的低 32 位。例如 eax 为 rax 的低 32 位。修改 eax 不影响 rax 高位部分。16 位寄存器同理。</p>\n<p>此外，16 位寄存器可分为 2 个 8 位寄存器。(AX: ah~al; BX: bh~bl; CX: ch~cl; DX: dh~dl) 分别表示高 8 位和低 8 位。</p>\n<table>\n<thead>\n<tr>\n<th>32 位</th>\n<th>64 位</th>\n<th>16 位</th>\n<th>名称</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>EAX</td>\n<td>RAX</td>\n<td>AX</td>\n<td>累加寄存器 (Accumulator)</td>\n<td>在乘法和除法指令中被自动使用；在 Win32 中，一般用在函数的返回值中。</td>\n</tr>\n<tr>\n<td>EBX</td>\n<td>RBX</td>\n<td>BX</td>\n<td>基址寄存器 (Base)</td>\n<td>DS 段中的数据指针</td>\n</tr>\n<tr>\n<td>ECX</td>\n<td>RCX</td>\n<td>CX</td>\n<td>计数寄存器 (Count)</td>\n<td>CPU 自动使用 ECX 作为循环计数器，在字符串和循环操作中常用，在循环指令（LOOP）或串操作中，ECX 用来进行循环计数，每执行一次循环，ECX 都会被 CPU 自动减一</td>\n</tr>\n<tr>\n<td>EDX</td>\n<td>RDX</td>\n<td>DX</td>\n<td>数据寄存器 (Data)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<img data-src=\"./Center.png\" alt=\"寄存器\" style=\"zoom:33%;\" />\n<h3 id=\"指令寄存器\"><a class=\"markdownIt-Anchor\" href=\"#指令寄存器\">#</a> 指令寄存器</h3>\n<table>\n<thead>\n<tr>\n<th>32 位</th>\n<th>64 位</th>\n<th>名称</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>EIP</td>\n<td>RIP</td>\n<td>指令指针寄存器 (Instruction Pointer)</td>\n<td>保存着下一条要执行的指令的地址。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"段寄存器\"><a class=\"markdownIt-Anchor\" href=\"#段寄存器\">#</a> 段寄存器</h3>\n<table>\n<thead>\n<tr>\n<th>寄存器</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CS</td>\n<td>代码段 (Code Segment)</td>\n</tr>\n<tr>\n<td>DS</td>\n<td>数据段 (Data Segment)</td>\n</tr>\n<tr>\n<td>SS</td>\n<td>堆栈段 (Stack Segment)</td>\n</tr>\n<tr>\n<td>ES</td>\n<td>附加数据段 (Extra Segment)</td>\n</tr>\n<tr>\n<td>FS</td>\n<td>附加数据段</td>\n</tr>\n<tr>\n<td>GS</td>\n<td>附加数据段</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"标志寄存器\"><a class=\"markdownIt-Anchor\" href=\"#标志寄存器\">#</a> 标志寄存器</h3>\n<h4 id=\"条件标志寄存器\"><a class=\"markdownIt-Anchor\" href=\"#条件标志寄存器\">#</a> 条件标志寄存器</h4>\n<table>\n<thead>\n<tr>\n<th>寄存器</th>\n<th>解释</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OF</td>\n<td>溢出标志位 (OverFlow Flag)</td>\n<td>用来反应有符号数加减法运算所得结果是否溢出。运算超出当前运算位数所能表示的范围，则称为溢出，标志位被置为 1，否则为 0。</td>\n</tr>\n<tr>\n<td>SF</td>\n<td>符号标志位 (Sign Flag)</td>\n<td>用来反应运算结果是否为 0。运算结果为负时置为 1，否则为 0。</td>\n</tr>\n<tr>\n<td>ZF</td>\n<td>零标志位 (Zero Flag)</td>\n<td>用来反应运算结果是否为 0。为零时置为 1，否则为 0。</td>\n</tr>\n<tr>\n<td>AF</td>\n<td>辅助进位标志位 (Auxilliary carry Flag)</td>\n<td>在字操作址，发生低字节向高字节进位或借位时该标志位被置为 1，否则为 0。</td>\n</tr>\n<tr>\n<td>PF</td>\n<td>奇偶标志位 (Parity Flag)</td>\n<td>用于反应结果中 “1” 的个数的奇偶性。如果 “1” 为偶数置为 1，否则为 0。</td>\n</tr>\n<tr>\n<td>CF</td>\n<td>进位标志位 (Carry Flag)</td>\n<td>运算结果的最高位产生了一个进位或错位，则该标志位置为 1，否则为 0。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"控制控制寄存器\"><a class=\"markdownIt-Anchor\" href=\"#控制控制寄存器\">#</a> 控制控制寄存器</h4>\n<table>\n<thead>\n<tr>\n<th>寄存器</th>\n<th>解释</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DF</td>\n<td>方向标志位 (Direction Flag)</td>\n<td>用于串操作指令中，控制地址的变化方向。当 DF 为 0 时，存储器地址自动增加；当 DF 为 1 时，存储器地址自动减少。</td>\n</tr>\n<tr>\n<td>IF</td>\n<td>中断标志位 (Interrupt Flag)</td>\n<td>用于控制外部可屏蔽中断是否可以被处理器响应。[^1]</td>\n</tr>\n<tr>\n<td>TF</td>\n<td>陷阱标志位 (Trap Flag)</td>\n<td>用于控制处理器是否进入单步操作方式。当 TF 为 0 时，处理器在正常模式下运行；当为 1 时，处理器单步执行指令，调试器可以逐步指令进行执行就是使用了该标志位。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"特殊64位调用函数传参\"><a class=\"markdownIt-Anchor\" href=\"#特殊64位调用函数传参\">#</a> 特殊：64 位调用函数传参</h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>寄存器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>rdi</strong></td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td><strong>rsi</strong></td>\n</tr>\n<tr>\n<td>3</td>\n<td>rdx</td>\n</tr>\n<tr>\n<td>4</td>\n<td>rcx</td>\n</tr>\n<tr>\n<td>5</td>\n<td>r8</td>\n</tr>\n<tr>\n<td>6</td>\n<td>r9</td>\n</tr>\n<tr>\n<td>7+</td>\n<td>从右向左压入栈中</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "汇编",
                "寄存器"
            ]
        }
    ]
}